var WebSocketWorker = function () { function f(e) { this._isLoadedProto = !1, this._loggerIsReady = !1, this._enableWorkerMode = e, this.clear() } return f.getLibFileRelativePath = function (e, t) { if (!e || !t || "" == t) return console.error("WebSocketWorker->getLibFileRelativePath() error manifestJson=" + e + " keyword=" + t), ""; for (var o = 0, r = e.initial.concat(e.game); o < r.length; o++) { var a = r[o], i = a.lastIndexOf("/"); if (0 <= i) if (a.substring(i).includes(t)) return a } return "" }, f.prototype.clear = function () { this._curMsgLength = 0, this._cacheDataBuff = [], this._cacheDataBuffLength = 0 }, f.prototype.onMessageFromMain = function (e) { var t = e[0]; switch (t) { case "loadedProto": if (this._isLoadedProto) return void console.error("protobuf is loaded"); this._isLoadedProto = !0, this.logToMain("start load protobuf lib"); for (var o = e[1][0], r = f.getLibFileRelativePath(o, f.THIS_FILE_NAME).split("/").length - 1, a = "", i = 0; i < r; i++)a += "../"; var s = f.getLibFileRelativePath(o, "protobuf"); s = a + s, importScripts(s); var n = e[1][1], h = new protobuf.Root, g = (protobuf.parse(n, h), "Bian"); self[g] = h[g], this.logToMain("protobuf Bian inited"); break; case "gotScoketData": var c = e[1]; this.onRawSocketData(c); break; case "clear": this.clear(); break; default: this.checkOtherMsg(t, e[1]) || this.logToMain("msg key not define =" + t, !0) } }, f.prototype.postMessageToMain = function (e, t, o) { void 0 === t && (t = null), void 0 === o && (o = !1), o && t ? postMessage([e, t], [t]) : postMessage([e, t]) }, f.prototype.onRawSocketData = function (e) { f.useMsgHeadModel ? (this.cacheDataBuffPush(e), this.tryDecodeDataBuff()) : this.processCompleteBuff(e) }, f.prototype.tryDecodeDataBuff = function () { if (!(this._cacheDataBuffLength <= 0)) { if (this._curMsgLength <= 0) { if (this._cacheDataBuffLength < f.DATA_HEAD_BYTE_LENGTH) return; var e = this.cacheDataBuffShift(f.DATA_HEAD_BYTE_LENGTH), t = new DataView(e); this._curMsgLength = t.getInt32(0) } if (this._curMsgLength <= 0) this.logToMain("包头解析异常", !0); else if (!(this._cacheDataBuffLength < this._curMsgLength)) { var o = this.cacheDataBuffShift(this._curMsgLength); this._curMsgLength = 0, this.processCompleteBuff(o), 0 < this._cacheDataBuffLength && this.tryDecodeDataBuff() } } }, f.prototype.processCompleteBuff = function (e) { if (e.byteLength > f.WORKER_DECODE_BYTE_LENGTH) { var t = new Uint8Array(e), o = Bian.Envelope.decode(t); this.gotOneProcessedNetBundle(o) } else this._enableWorkerMode ? this.postMessageToMain("gotUnProcessedArrayBuff", e, !0) : this.onGotUnProcessedArrayBuff(e) }, f.prototype.cacheDataBuffPush = function (e) { e && (this._cacheDataBuff.push(e), this._cacheDataBuffLength += e.byteLength) }, f.prototype.cacheDataBuffShift = function (e) { if (this._cacheDataBuffLength < e) return this.logToMain("cacheDataBuffShift error byteLenght=" + e + " curLength=" + this._cacheDataBuffLength), new ArrayBuffer(0); for (var t = new ArrayBuffer(e), o = new Uint8Array(t), r = null, a = null, i = 0, s = 0; s < this._cacheDataBuff.length; s++) { r = this._cacheDataBuff[s], a = new Uint8Array(r); for (var n = 0; n < r.byteLength && !(e <= i); n++)o[i] = a[n], i++; if (n >= r.byteLength) this._cacheDataBuff.shift(), this._cacheDataBuffLength -= r.byteLength, s--; else { var h = r.slice(n); this._cacheDataBuff[s] = h, this._cacheDataBuffLength -= n } if (e <= i) break } return t }, f.prototype.gotOneProcessedNetBundle = function (e) { this._enableWorkerMode ? this.postMessageToMain("gotProcessedNetBundle", e, !1) : this.onGotOneProcessedNetBundle(e) }, f.prototype.logToMain = function (e, t) { if (void 0 === t && (t = !1), this.onGotOneProcessedNetBundle) t ? Logger.error(LOG_TAG.NetWork, e) : Logger.log(LOG_TAG.NetWork, e); else { e = "[wsWorker]" + e; var o = t ? "error" : "log"; this.postMessageToMain("log", [o, e], !1) } }, f.prototype.checkOtherMsg = function (e, t) { switch (e) { case "Logger": return this.writeLog(t), !0; case "LoggerInit": return this.initLoggerDB(t), !0; default: return !1 } }, f.prototype.initLoggerDB = function (t) { var e = this; if (e._loggerIndexedDB) console.error("initLoggerDB repeated table=" + t); else if (e._loggerIndexedDB = indexedDB || self.mozIndexedDB || self.webkitIndexedDB || self.msIndexedDB, e._loggerIndexedDB) { e._loggerTable = t; var o = e._loggerIndexedDB.open("logDataBase"); o.onsuccess = function () { e._loggerDB = o.result, e._loggerDB.objectStoreNames.contains(t) ? e.initLoggerDBFinish() : console.error("worker init logger table error=" + t) }, o.onupgradeneeded = function () { var e = o.result; e.objectStoreNames.contains(t) || e.createObjectStore(t, { autoIncrement: !0 }) } } else console.error("indexedDB not supported") }, f.prototype.writeLog = function (e) { if (!this._loggerIsReady) return this._loggerCacheDataBeforeReady || (this._loggerCacheDataBeforeReady = []), void this._loggerCacheDataBeforeReady.push(e); this._loggerDB.transaction(this._loggerTable, "readwrite").objectStore(this._loggerTable).put(e) }, f.prototype.initLoggerDBFinish = function () { if (this._loggerIsReady = !0, this._loggerCacheDataBeforeReady && 0 != this._loggerCacheDataBeforeReady.length) for (var e = 0, t = this._loggerCacheDataBeforeReady; e < t.length; e++) { var o = t[e]; this.writeLog(o) } this._loggerCacheDataBeforeReady = null }, f.THIS_FILE_NAME = "WebSocketWorker", f.useMsgHeadModel = !1, f.DATA_HEAD_BYTE_LENGTH = 4, f.WORKER_DECODE_BYTE_LENGTH = 200, f }(), wsWorker = new WebSocketWorker(!0); onmessage = function (e) { e.data && e.data instanceof Array && 2 == e.data.length && "string" == typeof e.data[0] && wsWorker.onMessageFromMain(e.data) };